import { createClient } from '@supabase/supabase-js';
import type { SupabaseClient } from '@supabase/supabase-js';
import dotenv from 'dotenv';
dotenv.config();

// import { v4 as uuidv4 } from 'uuid'; // IDs are auto-generated by Supabase

// Define ENUM types based on your schema
type AgentType = 'inbound_voice' | 'browser' | 'outbound_voice';
const AGENT_TYPES: AgentType[] = ['inbound_voice', 'browser', 'outbound_voice'];

type LeadStatus = 'appointment_set' | 'declined' | 'no_answer' | 'follow_up' | 'new' | 'in_progress';
const LEAD_STATUSES: LeadStatus[] = ['appointment_set', 'declined', 'no_answer', 'follow_up', 'new', 'in_progress'];

// UPDATED CallAttemptStatus to match new DB enum
type CallAttemptStatus = 'queued' | 'initiated' | 'ringing' | 'in-progress' | 'completed' | 'busy' | 'failed' | 'no-answer' | 'canceled';
const CALL_ATTEMPT_STATUSES: CallAttemptStatus[] = ['queued', 'initiated', 'ringing', 'in-progress', 'completed', 'busy', 'failed', 'no-answer', 'canceled'];

// NEW CallAttemptResult enum
type CallAttemptResult = 'voicemail' | 'successful_ask' | 'appointment_set' | 'declined_ask' | 'requested_follow_up';
const CALL_ATTEMPT_RESULTS: CallAttemptResult[] = ['voicemail', 'successful_ask', 'appointment_set', 'declined_ask', 'requested_follow_up'];

// Configuration
const NUM_AGENTS = 5;
const NUM_LEADS = 20;
const MIN_CALL_ATTEMPTS_PER_LEAD = 1;
const MAX_CALL_ATTEMPTS_PER_LEAD = 3;

interface Agent {
  id: string;
  user_id?: string; // Assuming user_id might be optional or set by db
  name: string;
  type: AgentType;
  script?: string;
  description?: string;
  is_active: boolean;
  metadata?: object;
  ai_provider: string;
  ai_provider_agent_id?: string;
  team_id: string;
  tts_provider: string; // tts_providers enum
  stt_provider: string; // stt_providers enum
  llm_provider: string; // llm_providers enum
  phone_number?: string; // uuid, FK to phone_numbers
}

interface Lead {
  id: string;
  name?: string;
  phone: string;
  email?: string;
  source?: string;
  notes?: string;
  user_id?: string; // Assuming user_id might be optional
  status?: LeadStatus;
  team_id: string;
  address?: string;
}

// Add interfaces for Transcript structure
interface ToolCallFunction {
  name: string;
  arguments: string; // JSON string
}

interface ToolCall {
  id: string;
  type: 'function';
  function: ToolCallFunction;
}

interface TranscriptMessage {
  role: 'system' | 'user' | 'assistant' | 'tool';
  content?: string | null; // Content is null for some tool responses that only have tool_calls
  tool_calls?: ToolCall[];
  tool_call_id?: string; // For role: 'tool'
}

interface CallAttempt {
  id: string;
  lead_id: string;
  twilio_call_sid?: string;
  start_time: string; // ISO 8601 string
  end_time?: string; // ISO 8601 string
  duration?: number; // in seconds
  recording_url?: string;
  transcript?: TranscriptMessage[]; // Updated type
  result?: CallAttemptResult; // UPDATED to new ENUM type
  notes?: string;
  user_id?: string;
  status?: CallAttemptStatus; // UPDATED to new ENUM type
  team_id: string;
  to_number?: string;
  agent_id?: string;
}

interface Appointment {
  id: string;
  lead_id: string;
  call_attempt_id: string;
  scheduled_time: string; // ISO 8601 string
  duration: number; // in minutes
  status: 'scheduled' | 'confirmed' | 'completed' | 'cancelled' | 'no_show';
  notes?: string;
  reminder_sent?: boolean;
  user_id?: string;
  event_id?: string;
  meeting_type?: string;
  team_id: string;
  address?: string;
}

// Helper function to get random item from array
function getRandomElement<T>(arr: T[]): T {
  return arr[Math.floor(Math.random() * arr.length)];
}

// Helper function to generate random phone number
function getRandomPhoneNumber(): string {
  return `+1${Math.floor(1000000000 + Math.random() * 9000000000)}`;
}

// Helper function to generate random date in the past
function getRandomPastDate(daysAgo: number = 30): Date {
    const date = new Date();
    date.setDate(date.getDate() - Math.floor(Math.random() * daysAgo));
    return date;
}

// Helper function to generate random date in the future
function getRandomFutureDate(daysInFuture: number = 30): Date {
    const date = new Date();
    date.setDate(date.getDate() + Math.floor(Math.random() * daysInFuture) + 1); // +1 to ensure it's in the future
    return date;
}

// --- START TRANSCRIPT GENERATION FUNCTIONS ---

// Helper function to generate a very basic placeholder transcript
function generatePlaceholderTranscript(agentName: string, leadName: string, status: CallAttemptStatus): TranscriptMessage[] {
  return [
    {
      role: "system",
      content: `You are ${agentName}, a representative for Test Company. This call is currently ${status}.`
    },
    {
      role: "assistant",
      content: `Hi ${leadName}, this is ${agentName} from Test Company. Call status: ${status}.`
    }
  ];
}

function generateSuccessfulCallTranscript(
  agentName: string,
  leadName: string,
  leadPhoneNumber: string,
  leadAddress: string = "606 West McClellan Street in Flint Michigan" // Default if not provided
): TranscriptMessage[] {
  const today = new Date().toISOString().split('T')[0];
  const futureDate = getRandomFutureDate(7).toISOString().split('T')[0]; // Appointment within a week
  const callCheckId = `call_check_${Date.now()}`;
  const callScheduleId = `call_schedule_${Date.now()}`;
  const callUpdateLeadId = `call_update_lead_${Date.now()}`;

  return [
    {
      role: "system",
      content: `You are ${agentName}, a friendly and professional appointment setter for a Test Company.\nHere is a description of the company and their services: We provide excellent solutions.\nAdhere to the following script provided by your manager, maintaining a natural conversational tone.\nAsk the caller for their name if not known. Ask for their email.\nThe lead's address is sometimes known. If not, before scheduling an appointment, ask the caller for their address.\nWhen you call check_calendar_availability or schedule_appointment, always convert relative dates into an ISO YYYY-MM-DD literal (e.g. today â†’ ${today}).\nThe current date is ${today}.`
    },
    {
      role: "assistant",
      content: `Hi, is this ${leadName}? My name is ${agentName} calling from Test Company. Is this a good time to talk?`
    },
    { role: "user", content: `Yes, this is ${leadName}. And yes, it's an okay time.` },
    {
      role: "assistant",
      content: "Great! We're calling to see if you're interested in our services. Before we proceed, can I confirm your email and full address?"
    },
    { role: "user", content: `Sure, my email is ${leadName.toLowerCase().replace(/\s+/g, '')}@example.com and my address is ${leadAddress}.` },
    {
      role: "assistant",
      tool_calls: [{
        id: callCheckId, type: "function",
        function: { name: "check_calendar_availability", arguments: JSON.stringify({ date: futureDate, meeting_duration: 60 }) }
      }]
    },
    {
      role: "tool",
      tool_call_id: callCheckId,
      content: JSON.stringify({ available_times: ["09:00", "10:00", "14:00", "15:00"] })
    },
    {
      role: "assistant",
      content: `Okay ${leadName}, I've checked for ${futureDate}, and we have several slots. Would 10:00 AM work for you?`
    },
    { role: "user", content: `Yes, 10:00 AM on ${futureDate} sounds perfect.` },
    {
      role: "assistant",
      tool_calls: [{
        id: callScheduleId, type: "function",
        function: {
          name: "schedule_appointment",
          arguments: JSON.stringify({ address: leadAddress, date: futureDate, meeting_type: "Service Discussion", time: "10:00" })
        }
      }]
    },
    {
      role: "tool",
      tool_call_id: callScheduleId,
      content: JSON.stringify({ success: true, eventId: `evt_${Date.now()}`, appointment: [{ id: "mock_appt_id", lead_id: "mock_lead_id" }] })
    },
     {
      role: "assistant",
      tool_calls: [{
        id: callUpdateLeadId, type: "function",
        function: { name: "update_lead_status", arguments: JSON.stringify({ call_status: "appointment_scheduled", lead_status: "appointment_set" }) }
      }]
    },
    {
      role: "tool",
      tool_call_id: callUpdateLeadId,
      content: JSON.stringify({ success: true })
    },
    {
      role: "assistant",
      content: `Excellent! I've scheduled your appointment for ${futureDate} at 10:00 AM. We look forward to speaking with you then, ${leadName}!`
    }
  ];
}

function generateVoicemailTranscript(agentName: string, leadName: string): TranscriptMessage[] {
  return [
    {
      role: "system",
      content: `You are ${agentName}, a friendly representative for Test Company.`
    },
    {
      role: "assistant",
      content: `Hi ${leadName}, this is ${agentName} from Test Company. Sorry I missed you. I'll try to reach out again soon. You can also call us back at 1-800-555-TEST. Thanks!`
    }
  ];
}

function generateShortUnsuccessfulCallTranscript(agentName: string, leadName: string, reason: string): TranscriptMessage[] {
  let assistantMessage = `Hi ${leadName}, this is ${agentName} from Test Company. `;
  if (reason === 'no_answer') {
    assistantMessage += "It seems you're unavailable right now. I'll try again later.";
  } else if (reason === 'declined') {
    assistantMessage += "It seems now is not a good time or you're not interested. Thank you for your time.";
  } else if (reason === 'busy') {
    assistantMessage += "The line was busy. I'll try calling again shortly.";
  } else if (reason === 'failed') {
    assistantMessage += "There was an issue connecting the call. We'll attempt to resolve this.";
  } else { // for 'generic_connected' and any other unspecified cases
    assistantMessage += "Just giving you a call regarding our services. Is now a good time to talk briefly?";
  }
  return [
    {
      role: "system",
      content: `You are ${agentName}, a representative for Test Company.`
    },
    {
      role: "assistant",
      content: assistantMessage
    }
  ];
}

// --- END TRANSCRIPT GENERATION FUNCTIONS ---

// --- START DATABASE HELPER FUNCTIONS ---

async function getTeamPhoneNumberId(supabase: SupabaseClient, teamId: string): Promise<string | null> {
  console.log(`Querying for phone number for team ${teamId}...`);
  const { data, error } = await supabase
    .from('phone_numbers')
    .select('id')
    .eq('team_id', teamId)
    .limit(1);

  if (error) {
    console.error('Error querying phone numbers:', error);
    return null;
  }

  if (data && data.length > 0 && data[0].id) {
    console.log(`Found phone number ID: ${data[0].id} for team ${teamId}.`);
    return data[0].id;
  } else {
    console.warn(`No phone number found for team ${teamId}. Agents will be created without a phone number.`);
    return null;
  }
}

// --- END DATABASE HELPER FUNCTIONS ---

async function createAgents(supabase: SupabaseClient, teamId: string, count: number, phoneNumberId: string | null): Promise<Agent[]> {
  const agents: Agent[] = [];
  console.log(`Creating ${count} agents for team ${teamId}...`);
  for (let i = 0; i < count; i++) {
    const agentData: Partial<Agent> & { team_id: string; name: string; type: AgentType; is_active: boolean; ai_provider: string; tts_provider: string; stt_provider: string; llm_provider: string; } = {
      team_id: teamId,
      name: `Test Agent ${i + 1}`,
      type: getRandomElement(AGENT_TYPES),
      is_active: true,
      ai_provider: 'openai',
      tts_provider: 'groq',
      stt_provider: 'groq',
      llm_provider: 'groq',
      script: 'This is a test agent script.',
      description: 'A test agent created by populate script.',
    };
    if (phoneNumberId) {
      agentData.phone_number = phoneNumberId;
    }

    const { data, error } = await supabase.from('agents').insert(agentData).select();
    if (error) {
      console.error(`Error creating agent ${i + 1}:`, error);
      throw error;
    }
    if (data && data.length > 0) {
      console.log(`Agent ${data[0].name} (ID: ${data[0].id}) created.`);
      agents.push(data[0] as Agent);
    } else {
        console.warn('Agent insert did not return data for agent number: ' + (i+1));
    }
  }
  return agents;
}

async function createLeads(supabase: SupabaseClient, teamId: string, count: number): Promise<Lead[]> {
  const leads: Lead[] = [];
  console.log(`Creating ${count} leads for team ${teamId}...`);
  for (let i = 0; i < count; i++) {
    const leadData = {
      // id: uuidv4(), // ID is auto-generated by DB
      team_id: teamId,
      name: `Test Lead ${i + 1}`,
      phone: getRandomPhoneNumber(),
      email: `testlead${Date.now()}${i + 1}@example.com`,
      status: getRandomElement(LEAD_STATUSES),
      source: 'script_generated',
      // user_id: null, // Or associate
    };
    const { data, error } = await supabase.from('leads').insert(leadData).select();
    if (error) {
      console.error(`Error creating lead ${i + 1}:`, error);
      throw error;
    }
    if (data && data.length > 0) {
      console.log(`Lead ${data[0].name} (ID: ${data[0].id}) created.`);
      leads.push(data[0] as Lead);
    } else {
        console.warn('Lead insert did not return data for lead number: ' + (i+1));
    }
  }
  return leads;
}

async function createCallAttempts(supabase: SupabaseClient, teamId: string, leads: Lead[], agents: Agent[]): Promise<CallAttempt[]> {
  const callAttempts: CallAttempt[] = [];
  if (agents.length === 0 && NUM_AGENTS > 0) { // only warn if agents were expected
    console.warn("No agents available to assign to call attempts. Call attempts will be created without an agent_id.");
  }
  console.log(`Creating call attempts for ${leads.length} leads...`);

  // Define scenarios for call attempts
  interface CallScenario {
    description: string;
    status: CallAttemptStatus;
    result?: CallAttemptResult;
    generateTranscript: (agentName: string, leadName: string, leadPhone: string, leadAddress?: string) => TranscriptMessage[];
  }

  const callScenarios: CallScenario[] = [
    {
      description: "Appointment Set",
      status: 'completed',
      result: 'appointment_set',
      generateTranscript: (agentName, leadName, leadPhone, leadAddress) =>
        generateSuccessfulCallTranscript(agentName, leadName, leadPhone, leadAddress),
    },
    {
      description: "Voicemail Left",
      status: 'completed', // Assuming leaving a voicemail means the attempt is completed
      result: 'voicemail',
      generateTranscript: (agentName, leadName) =>
        generateVoicemailTranscript(agentName, leadName),
    },
    {
      description: "No Answer",
      status: 'no-answer',
      result: undefined,
      generateTranscript: (agentName, leadName) =>
        generateShortUnsuccessfulCallTranscript(agentName, leadName, 'no_answer'), // 'no_answer' reason for transcript
    },
    {
      description: "Busy Line",
      status: 'busy',
      result: undefined,
      generateTranscript: (agentName, leadName) =>
        generateShortUnsuccessfulCallTranscript(agentName, leadName, 'busy'), // 'busy' reason
    },
    {
      description: "Call Failed",
      status: 'failed',
      result: undefined,
      generateTranscript: (agentName, leadName) =>
        generateShortUnsuccessfulCallTranscript(agentName, leadName, 'failed'), // 'failed' reason
    },
    {
      description: "Declined Ask",
      status: 'completed',
      result: 'declined_ask',
      generateTranscript: (agentName, leadName) =>
        generateShortUnsuccessfulCallTranscript(agentName, leadName, 'declined'), // 'declined' reason
    },
    {
      description: "Successful Ask (no appt)",
      status: 'completed',
      result: 'successful_ask',
      generateTranscript: (agentName, leadName) => // Using generic for now
        generateShortUnsuccessfulCallTranscript(agentName, leadName, 'connected'), // 'connected' as a generic successful interaction
    },
    {
      description: "Requested Follow Up",
      status: 'completed',
      result: 'requested_follow_up',
      generateTranscript: (agentName, leadName) => // Using generic for now
        generateShortUnsuccessfulCallTranscript(agentName, leadName, 'connected'), // 'connected' implies interaction leading to follow-up
    },
    {
      description: "Queued",
      status: 'queued',
      result: undefined,
      generateTranscript: (agentName, leadName) =>
        generatePlaceholderTranscript(agentName, leadName, 'queued'),
    },
    {
      description: "Initiated",
      status: 'initiated',
      result: undefined,
      generateTranscript: (agentName, leadName) =>
        generatePlaceholderTranscript(agentName, leadName, 'initiated'),
    },
    {
      description: "Ringing",
      status: 'ringing',
      result: undefined,
      generateTranscript: (agentName, leadName) =>
        generatePlaceholderTranscript(agentName, leadName, 'ringing'),
    },
    {
      description: "In Progress",
      status: 'in-progress',
      result: undefined,
      generateTranscript: (agentName, leadName) =>
        generatePlaceholderTranscript(agentName, leadName, 'in-progress'),
    },
    {
      description: "Canceled",
      status: 'canceled',
      result: undefined,
      generateTranscript: (agentName, leadName) =>
        generatePlaceholderTranscript(agentName, leadName, 'canceled'),
    },
  ];

  for (const lead of leads) {
    const numAttempts = Math.floor(Math.random() * (MAX_CALL_ATTEMPTS_PER_LEAD - MIN_CALL_ATTEMPTS_PER_LEAD + 1)) + MIN_CALL_ATTEMPTS_PER_LEAD;
    for (let i = 0; i < numAttempts; i++) {
      const startTime = getRandomPastDate();
      const endTime = new Date(startTime.getTime() + Math.floor(Math.random() * 55 + 5) * 60000); // Add 5-60 mins
      const duration = Math.floor((endTime.getTime() - startTime.getTime()) / 1000);
      const selectedAgent = agents.length > 0 ? getRandomElement(agents) : null;
      const agentName = selectedAgent ? selectedAgent.name : "Agent";
      const leadName = lead.name || "Valued Customer";

      const scenario = getRandomElement(callScenarios);
      const transcript = scenario.generateTranscript(agentName, leadName, lead.phone, lead.address || undefined);

      const callAttemptData: Omit<CallAttempt, 'id' | 'user_id'> & { team_id: string } = { // Ensure required fields like team_id
        lead_id: lead.id,
        team_id: teamId, // Make sure teamId is passed correctly
        agent_id: selectedAgent ? selectedAgent.id : null,
        start_time: startTime.toISOString(),
        end_time: endTime.toISOString(),
        duration: duration,
        status: scenario.status,
        result: scenario.result,
        to_number: lead.phone,
        transcript: transcript,
        notes: `Call attempt ${i + 1} for lead ${lead.name}. Scenario: ${scenario.description}. Agent: ${selectedAgent ? selectedAgent.name : 'N/A'}.`
      };
      // Ensure user_id is handled if necessary, e.g. callAttemptData.user_id = selectedAgent?.user_id;

      const { data, error } = await supabase.from('call_attempts').insert(callAttemptData).select();
      if (error) {
        console.error(`Error creating call attempt for lead ${lead.id}:`, error);
        // Decide if one error should stop all: throw error;
        continue; // Continue to next attempt if one fails
      }
       if (data && data.length > 0) {
        console.log(`Call attempt (ID: ${data[0].id}) created for lead ${lead.name}.`);
        callAttempts.push(data[0] as CallAttempt);
      } else {
        console.warn('Call attempt insert did not return data for lead: ' + lead.id);
      }
    }
  }
  return callAttempts;
}

async function createAppointments(supabase: SupabaseClient, teamId: string, callAttempts: CallAttempt[]): Promise<Appointment[]> {
  const appointments: Appointment[] = [];
  // UPDATED: Filter for appointments based on new status and result
  const potentialAppointments = callAttempts.filter(
    ca => ca.status === 'completed' && ca.result === 'appointment_set'
  );
  console.log(`Creating appointments for ${potentialAppointments.length} suitable call attempts...`);

  for (const callAttempt of potentialAppointments) {
    const scheduledTime = getRandomFutureDate();
    const appointmentData = {
      // id: uuidv4(), // ID is auto-generated
      lead_id: callAttempt.lead_id,
      call_attempt_id: callAttempt.id,
      team_id: teamId,
      scheduled_time: scheduledTime.toISOString(),
      duration: 60, // Default duration 60 minutes
      status: 'scheduled' as Appointment['status'],
      notes: `Appointment scheduled via script from call attempt ${callAttempt.id}.`,
      // user_id: callAttempt.user_id, // Or based on agent/lead
    };

    const { data, error } = await supabase.from('appointments').insert(appointmentData).select();
    if (error) {
      console.error(`Error creating appointment for call_attempt ${callAttempt.id}:`, error);
      // Decide if one error should stop all: throw error;
      continue; // Continue to next appointment if one fails
    }
    if (data && data.length > 0) {
      console.log(`Appointment (ID: ${data[0].id}) created for lead ${callAttempt.lead_id}.`);
      appointments.push(data[0] as Appointment);
    } else {
        console.warn('Appointment insert did not return data for call_attempt: ' + callAttempt.id);
    }
  }
  return appointments;
}


async function main() {
  const args = process.argv.slice(2);
  const teamIdArg = args.find(arg => !arg.startsWith('--'));
  const envArg = args.find(arg => arg.startsWith('--env='));

  if (!teamIdArg) {
    console.error("Error: teamId is required.");
    console.log("Usage: ts-node populate_test_data.ts <teamId> [--env=dev|prod]");
    process.exit(1);
  }
  const teamId = teamIdArg;

  let env = 'prod'; // Default environment
  if (envArg) {
    const envValue = envArg.split('=')[1];
    if (envValue === 'dev' || envValue === 'prod') {
      env = envValue;
    } else {
      console.warn(`Warning: Invalid --env value "${envValue}". Using default "prod".`);
    }
  }
  console.log(`Running script for teamId: ${teamId} in ${env} environment.`);

  // const supabaseServiceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
  let supabaseServiceRoleKey: string | undefined;
  let supabaseUrl: string | undefined;

  if (env === 'dev') {
    supabaseUrl = process.env.NEXT_PUBLIC_DEV_SUPABASE_URL || process.env.NEXT_PUBLIC_SUPABASE_URL;
    supabaseServiceRoleKey = process.env.NEXT_PUBLIC_DEV_SUPABASE_SERVICE_ROLE_KEY;
  } else {
    supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
    supabaseServiceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
  }

  if (!supabaseUrl) {
    console.error("Error: Supabase URL is not defined. Set NEXT_PUBLIC_SUPABASE_URL (and optionally NEXT_PUBLIC_DEV_SUPABASE_URL for dev env).");
    process.exit(1);
  }
  if (!supabaseServiceRoleKey) {
    let errorMessage = "Error: Supabase Service Role Key is not defined. ";
    if (env === 'dev') {
      errorMessage += "Set NEXT_PUBLIC_DEV_SUPABASE_SERVICE_ROLE_KEY for dev environment.";
    } else {
      errorMessage += "Set SUPABASE_SERVICE_ROLE_KEY for prod environment.";
    }
    console.error(errorMessage);
    process.exit(1);
  }

  const supabase = createClient(supabaseUrl, supabaseServiceRoleKey);
  console.log(`Supabase client initialized for ${supabaseUrl}`);

  try {
    // 0. Get a phone number for the team
    const teamPhoneNumberId = await getTeamPhoneNumberId(supabase, teamId);

    // 1. Create Agents
    const agents = await createAgents(supabase, teamId, NUM_AGENTS, teamPhoneNumberId);
    if (agents.length === 0 && NUM_AGENTS > 0) {
        console.warn("No agents were created. Subsequent steps might fail or create incomplete data.");
    }

    // 2. Create Leads
    const leads = await createLeads(supabase, teamId, NUM_LEADS);
     if (leads.length === 0 && NUM_LEADS > 0) {
        console.warn("No leads were created. Subsequent steps will be skipped.");
        // Optionally exit if no leads, as other data depends on it
        // process.exit(0); 
        return; // End execution if no leads
    }

    // 3. Create Call Attempts
    const callAttempts = await createCallAttempts(supabase, teamId, leads, agents);
    if (callAttempts.length === 0 && leads.length > 0 && (MAX_CALL_ATTEMPTS_PER_LEAD > 0 || MIN_CALL_ATTEMPTS_PER_LEAD > 0)) {
        console.warn("No call attempts were created.");
    }
    
    // 4. Create Appointments for 'appointment_scheduled' call attempts
    const appointments = await createAppointments(supabase, teamId, callAttempts);
    
    console.log("\n--- Data Population Summary ---");
    console.log(`Created ${agents.length} agents.`);
    console.log(`Created ${leads.length} leads.`);
    console.log(`Created ${callAttempts.length} call attempts.`);
    console.log(`Created ${appointments.length} appointments.`);
    console.log("\nScript finished successfully!");

  } catch (error) {
    console.error("\n--- Script failed ---");
    // Check if error is an object and has a message property before trying to print it.
    if (error instanceof Error) {
        console.error("An error occurred during data population:", error.message);
        if (error.stack) {
            console.error(error.stack);
        }
    } else {
        console.error("An unknown error occurred during data population:", error);
    }
    process.exit(1);
  }
}

main().catch(err => {
    if (err instanceof Error) {
        console.error("Unhandled error in main execution:", err.message);
        if (err.stack) {
            console.error(err.stack);
        }
    } else {
        console.error("An unhandled unknown error in main execution:", err);
    }
  process.exit(1);
}); 